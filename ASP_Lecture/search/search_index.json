{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Scientific Programming - An Introduction","text":"<p>The present lecture notes, heavily under construction,s are on-going notes for a class taught at SJTU for Math undergraduate students.</p>"},{"location":"#what-is-this-lecture-not-about","title":"What is this lecture NOT about","text":"<ul> <li>NOT about computer theory</li> <li>NOT about inner aspects of programming</li> <li>NOT about procedural/functional/OO or whatever programming method</li> <li>NOT about algo/complexity theory</li> </ul>"},{"location":"#who-is-this-lecture-for","title":"Who is this lecture for","text":"<ul> <li>Introdution to programming with emphasis from a mathematical viewpoint and formalism</li> <li>Understanding programming from a fundamental viewpoint rather than technical one (ChatGPT does the technique)</li> <li>Don't need to be a math wizz just basic calculus and algebra are needed</li> <li>Implement scientic computations</li> <li>Handling data in an organized fashion</li> </ul>"},{"location":"#what-to-expect","title":"What to expect","text":"<p>At the end of this lecture you should be able among others to</p> <ul> <li>Implement scientific computations (optimization, integration, dynamical systems, monte carlo, some ML etc.)</li> <li>Organize, clean and query data correctly</li> <li>Debug, optimize your implementations</li> <li>Organize and implement a complex project with the right choice of tools and architecture.</li> </ul>"},{"location":"#python-as-main-programming-language","title":"Python as main programming language","text":"<p>The choive of the programming language for this lecture is Python for the following reasons:</p>"},{"location":"#natural-syntax","title":"Natural Syntax:","text":"<p>Compare C++ <pre><code>#include &lt;iostream.h&gt;\nvoid main()\n{\ncout &lt;&lt; \"Hello world\" &lt;&lt; endl;\n}\n</code></pre> with Python <pre><code>print(\"Hello world\")\n</code></pre></p> <p>As mathematicians it is also one of the languages that is the closest to the mathematical formalism which usually require write less, express more conceptually.</p>"},{"location":"#portable","title":"Portable:","text":"<ul> <li>Python, as R for instance, is a scripting language. You can run pieces of code on the go and see the result. This makes it easy to prototype and test ideas. It has however several drawbacks if not used correctly.</li> <li>Since there is no need to compile the code can be ported on any operating system supporting python (Linux, Mac, Windows, Android, IOS, etc.)</li> </ul>"},{"location":"#versatile","title":"Versatile","text":"<ul> <li>General purpose language (OO or functional programing can be used formally)</li> <li>Application for data analysis and ML but also website, automating tasks, etc.</li> <li>Can interact with other languages relatively easily</li> <li>Good balance between low and high level language</li> </ul>"},{"location":"#huge-community-and-footprint","title":"Huge community and footprint","text":"<ul> <li>Presently among the top 3 most used programming language</li> <li>First language of choice for data analysis, machine learning, AI</li> <li> <p>Immense, well maintained and open sourced major libraries to name but a few:</p> <ul> <li><code>numpy</code>, <code>pyarrow</code>, <code>pandas</code> for multidimensional arrays and tabular data</li> <li><code>scipy</code>, <code>statsmodels</code>, <code>nlop</code> for scientific computing</li> <li><code>pytorch</code>, <code>tensorflow</code>, <code>scikitlearn</code> for machine learning and AI</li> <li><code>matplotlib</code>, <code>seaborn</code>, <code>plotly</code> for data visualization</li> </ul> </li> <li> <p>Most active language on Github (Matlab is nowhere in the top 20...)</p> </li> </ul>"},{"location":"#requirements-from-the-job-market","title":"Requirements from the job market","text":"<p>Familiarity with python and the related data anlysis libraries is now required for most jobs</p> <ul> <li>Financial industry, CS, data analysis companies, etc.</li> <li>Automation tasks, web.</li> <li>As a basic command of excel was required several years ago, now it is Python.</li> </ul>"},{"location":"#open-source","title":"OPEN SOURCE","text":"<p>Python has been created as a programming language by Guido van Rossum who released the program language and maintained it for over 30 years as an open source language.</p> <p></p> <p>Open source ecosystem allowed to have large communities working across the world to develop the ecosystem. Furthermore, it is an essential auditing process so as to see if the language does what it shall.</p>"},{"location":"material/","title":"Material","text":"<p>Any normal computer with either Linux, Windows of MacOS will do it.</p> <p>What is primarily needed:</p> <ul> <li>Python</li> <li>A Code editor</li> </ul>"},{"location":"material/#python","title":"Python","text":"<p>Python can be installed in many different ways (In linux it is for instance most of the time already in the system). Several python (with different versions) can run under the same computer.</p> <p>However the most simple and best advice is to use Anaconda</p> <ol> <li>Step 1: Download Anaconda for your platform</li> <li>Step 2: Install on your computer</li> </ol> Miniconda <p>Anaconda comes with a GUI software to manage the environment and packages with point and click. It also installs a default set of packages such as <code>Jupyther</code>, <code>numpy</code>, etc. If you prefer to install a minimal version and install only the packages you need one after the other you can install Miniconda</p> <p>Anaconda usually comes with a python interpreter called <code>ipython</code> that allows to run code directly from a console or an editor.</p>"},{"location":"material/#code-editor","title":"Code Editor","text":"<p>Two write code you only need an editor, however dedicated editors allows you to program more efficiently.</p> <ul> <li>Jupyther Notebook:     Allows you to run on the browser so called notebook where you can input code, text, and run each cell.     Good for pure beginner.</li> <li>VSCode:     Is a multi platform open source editor maintained and released by Microsoft.     It is a great environment for development.     The principle is that it is a basic editor in which you can install so called plugins (mini apps like in wechat or allipay).     Download and install.     Then go to the plugins repository and install the <code>python</code> plugin from Microsoft.</li> </ul> <p>Good practice</p> <p>It is recommended to have a directory in your computer containing your code files (for organization purposes and also because python will run as environment in this directory).</p>"},{"location":"material/#installing-additional-libraries","title":"Installing additional libraries","text":"<p>Python can be extended with libraries this is one of the strength of it that will perform tasks for you. Installing a new library can be done in three ways with anaconda:</p> <ol> <li>Use the GUI and search for the library</li> <li>Open a terminal and type <code>conda install &lt;library&gt;</code></li> <li>Open a terminal and use pip with <code>pip install &lt;library&gt;</code></li> </ol> <p>Warning</p> <p>The first and second options are preferable usually. Indeed, libraries have a complex system of inter-dependence and since you are likely using Anaconda, the tool <code>conda</code> will manage the inter-dependence of each packages better. It is however slower.</p>"},{"location":"material/#which-libraries","title":"Which libraries","text":"<p>In the lecture we will use quite a lot of libraries and install them on the go. Fundamentally the following ones will be recurrent</p> <ul> <li><code>numpy</code>: multidimensional array library</li> <li><code>pandas</code>: data analysis (tabular) framework </li> <li><code>scipy</code>: scientific library</li> <li><code>pytorch</code>: AI and ML library with tensors</li> <li><code>plotly</code>: Data visualization</li> </ul>"},{"location":"lecture/00-introduction/","title":"Introduction","text":""},{"location":"lecture/00-introduction/#about-computing-something","title":"About Computing Something","text":"<p>When we speak about programming language, scientific computing, from a simplistic viewpoint we want to give a meaning to \\(x \\mapsto f(x)\\). In other terms, given an input \\(x\\) we want to transform this input into and output \\(f(x)\\).</p> Examples: <ul> <li> <p>A constant function \\(f\\) printing <code>Hello World</code>: </p> \\[x \\mapsto \\text{``Hello World!''}\\] </li> <li> <p>A function computing the exponential of \\(x\\):</p> \\[x \\mapsto e^x\\] </li> <li> <p>etc.</p> </li> </ul> <p>Defining, using, composing functions is a natural thing for mathematicians. The question is however whether it is possible to design a machine that will accomplish this task. The idea of such a machine dates backs centuries ago, basically machine that are designed to perform basic arithmetic such as finger counting. They were of mechanical nature such as abacus, suanpan (), Pascaline or various compass and astronomical devices.</p> <p>Many evolutions happened during the 19th and beginning of 20th century of mechanical nature, but the first real modern version of a computer how we know them was done by Suze around 1939-40 where he designed a computer using electric signals (with vaccum tubes) rapidly followed by the works of Turing or von Neumann. This period coincide with an intense work in the mathematical community about the foundations of mathematics.</p> <p>Without entering into the history of computers and their inner functioning, let us notice the following. For mathematics one starts with logic, axiomatic set theory, then build up natural numbers \\(\\mathbb{N}\\), rational numbers \\(\\mathbb{Q}\\), real numbers \\(\\mathbb{R}\\), vector spaces, manifolds, etc. and functions on each of these spaces.</p> <p>If one wants to perform computations in a mathematical sense, one would need those elements. Starting with a simple two elements logical Boolean Algebra <code>{True, False}</code>, it holds </p> <ul> <li>Or: <code>True or True = True</code>, <code>True or False = True</code>, <code>False or False = False</code></li> <li>And: <code>True and True = True</code>, <code>True and False = False</code>, <code>False and False = False</code></li> <li>Negation: <code>~True = False</code>, <code>~False = True</code></li> </ul> <p>Boolean algebra or set theoretical viewpoint</p> <p>This can be written in terms of</p> <ul> <li>\\(X = \\{0,1\\}\\) boolean algebra as \\(1 + 1 = 1\\) where \\(1\\) stands for <code>True</code> and \\(+\\) for <code>or</code>. Same for \\(0\\) standing for <code>False</code>, \\(*\\) for <code>and</code>.</li> <li>\\(X = 2^{\\emptyset}=\\{\\emptyset, \\{\\emptyset\\}\\}\\) as \\(\\{\\emptyset\\}\\cup \\{\\emptyset\\} = \\{\\emptyset\\}\\) where \\(\\{\\emptyset\\}\\) stands for <code>1</code> and \\(\\cup\\) for <code>or</code>i. Similarly \\(\\emptyset\\) stands for \\(0\\), \\(\\cap\\) stands for <code>and</code> and the complement \\({}^c\\) stands for <code>~</code>.</li> </ul> <p>Starting with these premises, following John von Neumann method, one can within ZF theory construct natural numbers, and from there integers, rational numbers etc. At least building a finite arithmetic.</p> <p>Hence for a computer to work, one needs in the first place</p> <ol> <li>A \\(0\\) and \\(1\\) (or <code>False/True</code> states)</li> <li>The operations <code>or</code>, <code>and</code> and <code>~</code></li> <li>A way to read the input and output of those operations (challenge in quantum computing for instance which is slightly different)</li> </ol> <p>As for the \\(0\\), \\(1\\), the invention of electricity allows to produce and measure presence of current (or absence thereof). As for the operations, they are generated by the invention of so transistors that can generate gates performing those operations.</p> <p>The first attempts tried to get working into a decimal world, however it turns out that from this setting working in base 2 is more efficient and closer to what the circuitry allows, and since mathematically it does not matter what base is used, binary it be.</p>"},{"location":"lecture/00-introduction/#talking-to-a-machine","title":"Talking to a Machine","text":"<p>The machine can now deal with finite arithmetic, in other terms, we can do simple \\(x \\mapsto f(x)\\). However, it remains complicated to explain this machine</p> <ul> <li>what \\(x\\) (the input) is. (Convert into binary sequence)</li> <li>how it shall transform \\(x\\) into \\(f(x)\\) with such basic operations</li> <li>how to read out the output (for instance from binary to decimal and print it on a screen or record it somewhere)</li> </ul> <p>This is where programming languages come into place. Like any language, they are characterized by a syntax (form) and semantics (meaning). One receiving end is the computer with a very rudimentary form (made of 0/1 and operations on it), while the other is a human with sophisticated one. Hence programming languages are often classified from low level (close to the machine language) to high level (close to human language). Here is a personal ranking of programing languages along this dimension</p> <ul> <li> <p>(Extremely) Low level:     Those languages are the closest to the machine code instructions.     They are extremely efficient as there is no overhead between the instructions and the computer.     However, beyond simple but critical operations, it is virtually impossible to express more complex framework in reasonable amount of time.     Classical example of which is the assembly language.     Current applications are rare but very specific (flight instruments, rockets, cryptography, special algorithm).     Example of assembly language<pre><code>Example:  M  ADD  R1, ='3'\nwhere, M - Label; ADD - symbolic opcode; \nR1 - symbolic register operand; (='3') - Literal\n\nAssembly Program:\nLabel  Op-code   operand   LC value(Location counter)\nJOHN   START     200\n       MOVER     R1, ='3'    200\n       MOVEM     R1, X       201\nL1     MOVER     R2, ='2'    202\n       LTORG                 203\nX      DS        1           204\n       END                   205\n</code></pre></p> </li> <li> <p>Low level:      Those programming languages are also of procedural nature but with a more natural syntax and semantic with advanced multipurpose functionalities (control flows, recursion, functions, or advanced data structure).     They remain close enough to the machine to be very efficient and do not allow for higher level concepts (templating, objects, etc) and require care how to handle memory.     Typical examples are <code>FORTRAN</code>, <code>C</code> or more recently <code>Rust</code>, <code>CUDA</code>.     They are still very widely used as they are the backbones of many infrastructures and operating system (Linux for instance) as well as scientific libraries.</p> FortranCRust <pre><code>program fibonacci\n    implicit none\n    integer :: n, i\n    integer, allocatable :: fib(:)\n\n    print *, 'Enter the number of terms:'\n    read *, n\n\n    allocate(fib(n))\n\n    fib(1) = 0\n    if (n &gt; 1) fib(2) = 1\n\n    do i = 3, n\n        fib(i) = fib(i-1) + fib(i-2)\n    end do\n\n    print *, 'Fibonacci sequence:'\n    do i = 1, n\n        print *, fib(i)\n    end do\n\n    deallocate(fib)\nend program fibonacci\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nvoid fibonacci(int n) {\n    int t1 = 0, t2 = 1, nextTerm;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        printf(\"%d, \", t1);\n        nextTerm = t1 + t2;\n        t1 = t2;\n        t2 = nextTerm;\n    }\n}\n\nint main() {\n    int n;\n    printf(\"Enter the number of terms: \");\n    scanf(\"%d\", &amp;n);\n    printf(\"Fibonacci Sequence: \");\n    fibonacci(n);\n    return 0;\n}\n</code></pre> <pre><code>fn fibonacci(n: u32) -&gt; u32 {\n    let (mut a, mut b) = (0, 1);\n    for _ in 0..n {\n        let temp = a;\n        a = b;\n        b = temp + b;\n    }\n    a\n}\n\nfn main() {\n    let n = 10; // Example: first 10 Fibonacci numbers\n    for i in 0..n {\n        println!(\"{}\", fibonacci(i));\n    }\n}\n</code></pre> <ul> <li>Medium level:  With more complex needs and larger projects, languages have been extended in terms of functionalities such as memory managment, object oriented or functional programing. On the one hand, they often remove many difficulties related to lower level languages such as addressing and managing the memory, implement asynchronous or parallel programing, and make use of objects or more general structures. They are tons of such languages with each its own philosohy, most wiedely known are <code>C++</code>, <code>Java</code>, <code>Haskell</code> (functional programming language), <code>JavaScript</code> (web oriented), etc. They are still very efficient and used in infrastructure or many web related applications.</li> </ul> C++JavaHaskell <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Circle {\npublic:\n    Circle(double radius) : radius(radius) {}  // Constructor\n\n    double area() const {\n        return radius * radius * 3.14159;\n    }\n\nprivate:\n    double radius;\n};\n\nint main() {\n    Circle circle(5.0);  // Create a Circle object\n    cout &lt;&lt; \"Area of the circle: \" &lt;&lt; circle.area() &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <pre><code>public class Circle {\n    private double radius;\n\n    public Circle(double radius) {\n        this.radius = radius;\n    }\n\n    public double area() {\n        return radius * radius * Math.PI;\n    }\n\n    public static void main(String[] args) {\n        Circle circle = new Circle(5.0);\n        System.out.println(\"Area of the circle: \" + circle.area());\n    }\n}\n</code></pre> <pre><code>data Circle = Circle Double  -- Circle type with a single constructor\n\narea :: Circle -&gt; Double\narea (Circle radius) = pi * radius ^ 2\n\nmain :: IO ()\nmain = print $ area $ Circle 5.0\n</code></pre> <ul> <li>Higher level: Those programing language takes the previous level type but focus on simplifying the syntax and semantics, removing lot of the compilation/debugging work as well as static typing requirements (specifying the neture of all variable before use). They are also by definition very dynamic (objects can be declared at running time) and interpreted (scripting language). Paramount example of which is <code>Python</code> but also <code>Lua</code>, <code>Ruby</code>, etc. They are also programming languages with specific application at hand such as <code>R</code>, <code>Matlab</code>, <code>Mathematica</code>.</li> </ul> PythonRMatlab <pre><code>import numpy as np\n\n# Define an array of numbers\ndata = np.array([1, 2, 3, 4, 5])\n\n# Calculate the mean and standard deviation\nmean = np.mean(data)\nstd_dev = np.std(data)\n\nprint(\"Mean:\", mean)\nprint(\"Standard Deviation:\", std_dev)\n</code></pre> <pre><code># Define a vector of numbers\ndata &lt;- c(1, 2, 3, 4, 5)\n\n# Calculate the mean and standard deviation\nmean &lt;- mean(data)\nstd_dev &lt;- sd(data)\n\nprint(paste(\"Mean:\", mean))\nprint(paste(\"Standard Deviation:\", std_dev))\n</code></pre> <pre><code>% Define an array of numbers\ndata = [1, 2, 3, 4, 5];\n\n% Calculate the mean and standard deviation\nmean_val = mean(data);\nstd_dev = std(data);\n\ndisp(['Mean: ', num2str(mean_val)])\ndisp(['Standard Deviation: ', num2str(std_dev)])\n</code></pre> <ul> <li>**(Extremely) high level: <code>ChatGPT</code>. This is not really a programming language but as a large langage model it can perform the task of converting natural langage into code. More advanced models such as google code are trained to design algorithm that are more efficient than those written by human beings. </li> </ul> </li> </ul> <p>As you can see, <code>ChatGPT</code> or more generally those LLM are game changer on how we approach programming languages.  So why shall we learn how to program? In the end it is not necessary anymore to have a large proficiency in low or middle level programming languages. However, it is important to understand how a machine is generating output, how to design programs and then ask any AI to help you along the way. </p>"},{"location":"lecture/01-first-steps/","title":"First Steps Data Structure","text":"<p>We start with the most simple example, namely a constant function that will print a message <pre><code>print(\"Hello world!\")\n</code></pre></p>"},{"location":"lecture/01-first-steps/#variables","title":"Variables","text":"<p>In math, declaring variables is bottom line and done like</p> \\[ \\text{Let }a =\\sqrt{\\pi} \\] <p>In python this is the same way <pre><code>a = 1\nprint(\"The value of a is now:\", a)\n</code></pre></p> <p>Equal is not Equal</p> <p>In math the symbol \\(=\\) has a very special meaning, it is a binary relation which transitive, symetric and antisymetric. But it is also colloquialy used as definition means as above. In python <code>=</code> means definition or assignment. It is not a reflexive relation meaning that <code>1 =a</code> if <code>a</code> was not defined before will not work. Also <code>a =1</code> and <code>b=2</code>, then <code>a=b</code> should return an error, while here it just reassign <code>b</code> to <code>a</code>.</p> <p>Variables are automatically mutable, means that another assignation will override it</p> <pre><code>a = 3\nprint(\"Value of a is\", a)\na = 5\nprint(\"The value of a is now\", a)\n</code></pre> <p>Variable can be assigned to other variables. Those assignations are copies and therefore independent objects</p> <pre><code>a = 5\nb = a\nprint(\"The value of a is\", a, \"and the value of b is\", b)\n# If I reassign a it will change a but not b --&gt;\na = 6\nprint(\"The value of a is now\", a, \"and the value of b remains\", b)\n</code></pre>"}]}